// Generated by LiveScript 1.5.0
(function(){
  var vm, fs, path, lodash, yargs, livescript, async, DBG, LOAD_LIVESCRIPT, TO_MERMAID_SENSOR_FIELDS, GET_SENSOR_TYPES, GET_SENSOR_FIELD_NAMES, GET_SENSOR_FIELD_NAMES_FOR_MARKDOWN, Class, ClassManager, argv, schema, format, verbose, output;
  vm = require('vm');
  fs = require('fs');
  path = require('path');
  lodash = require('lodash');
  yargs = require('yargs');
  livescript = require('livescript');
  async = require('async');
  global.verbose = false;
  DBG = function(message){
    if (global.verbose) {
      return console.error("DBG: " + message);
    }
  };
  LOAD_LIVESCRIPT = function(fullpath, done){
    return fs.readFile(fullpath, function(err, buffer){
      var text, js, script, sandbox, context, error;
      if (err != null) {
        return done(err);
      }
      text = buffer + "";
      try {
        js = livescript.compile(text);
        script = new vm.Script(js);
        sandbox = {
          module: {}
        };
        context = vm.createContext(sandbox);
        script.runInContext(context);
        return done(null, sandbox.module.exports);
      } catch (e$) {
        error = e$;
        return done(error);
      }
    });
  };
  TO_MERMAID_SENSOR_FIELDS = function(name, st, fields){
    var xs, res$, i$, len$, f, x;
    res$ = [];
    for (i$ = 0, len$ = fields.length; i$ < len$; ++i$) {
      f = fields[i$];
      res$.push([name, st + " : " + f.field]);
    }
    xs = res$;
    res$ = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      res$.push(x.join(' : '));
    }
    xs = res$;
    xs.push(name + " : --------");
    return xs;
  };
  GET_SENSOR_TYPES = function(c){
    var superclass, sensorTypes, types, res$, k, v;
    if (c == null) {
      return [];
    }
    superclass = c.superclass, sensorTypes = c.sensorTypes;
    res$ = [];
    for (k in sensorTypes) {
      v = sensorTypes[k];
      res$.push(k);
    }
    types = res$;
    if (superclass == null) {
      return types;
    }
    return types.concat(GET_SENSOR_TYPES(superclass));
  };
  GET_SENSOR_FIELD_NAMES = function(fields){
    var f;
    return (function(){
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = fields).length; i$ < len$; ++i$) {
        f = ref$[i$];
        results$.push(f.field);
      }
      return results$;
    }());
  };
  GET_SENSOR_FIELD_NAMES_FOR_MARKDOWN = function(fields){
    var names, res$, i$, len$, n;
    names = GET_SENSOR_FIELD_NAMES(fields);
    res$ = [];
    for (i$ = 0, len$ = names.length; i$ < len$; ++i$) {
      n = names[i$];
      res$.push("`" + n + "`");
    }
    names = res$;
    return names.join(", ");
  };
  Class = (function(){
    Class.displayName = 'Class';
    var prototype = Class.prototype, constructor = Class;
    function Class(clazz, manager){
      var displayName;
      this.clazz = clazz;
      this.manager = manager;
      displayName = clazz.displayName;
      this.name = displayName;
      this.subclasses = [];
      this.p_type = lodash.snakeCase(this.name);
      return;
    }
    Class.prototype.init = function(done){
      var self, ref$, name, manager, p_type, clazz, dummy, names, res$, k, v, sensorTypes, n, superclass;
      ref$ = self = this, name = ref$.name, manager = ref$.manager, p_type = ref$.p_type, clazz = ref$.clazz;
      DBG("parsing " + name + ": => " + p_type);
      dummy = self.dummy = new clazz({});
      res$ = [];
      for (k in dummy) {
        v = dummy[k];
        if (k !== 'constructor') {
          res$.push(k);
        }
      }
      names = res$;
      sensorTypes = self.sensorTypes = (function(){
        var i$, ref$, len$, resultObj$ = {};
        for (i$ = 0, len$ = (ref$ = names).length; i$ < len$; ++i$) {
          n = ref$[i$];
          resultObj$[n] = dummy[n];
        }
        return resultObj$;
      }());
      DBG("parsing " + name + ": => " + JSON.stringify(sensorTypes));
      if (clazz.superclass == null) {
        return done();
      }
      superclass = self.superclass = manager.getClazz(clazz.superclass.displayName);
      if (superclass == null) {
        return done("cannot find super class " + clazz.superclass.displayName + " of " + name);
      }
      superclass.subclasses.push(self);
      return done();
    };
    Class.prototype.toJson = function(){
      var self, ref$, name, superclass, p_type, sensorTypes, parent;
      ref$ = self = this, name = ref$.name, superclass = ref$.superclass, p_type = ref$.p_type, sensorTypes = ref$.sensorTypes;
      parent = superclass != null ? superclass.name : null;
      return {
        name: name,
        parent: parent,
        p_type: p_type,
        sensorTypes: sensorTypes
      };
    };
    Class.prototype.toOutputJson = function(){
      var self, ref$, name, superclass, p_type, sensorTypes, parent, s_types, res$, k, v, res1$, i$, len$, f;
      ref$ = self = this, name = ref$.name, superclass = ref$.superclass, p_type = ref$.p_type, sensorTypes = ref$.sensorTypes;
      parent = superclass != null ? superclass.name : null;
      res$ = {};
      for (k in sensorTypes) {
        v = sensorTypes[k];
        res1$ = [];
        for (i$ = 0, len$ = v.length; i$ < len$; ++i$) {
          f = v[i$];
          res1$.push(f.field);
        }
        res$[k] = res1$;
      }
      s_types = res$;
      return {
        name: name,
        parent: parent,
        p_type: p_type,
        s_types: s_types
      };
    };
    Class.prototype.dumpMermaidClass = function(dumpChild, simple){
      var self, ref$, name, subclasses, sensorTypes, ss, xs, res$, i$, len$, child, ys, st, o, x, j$, len1$, y, zs, text, children, c;
      dumpChild == null && (dumpChild = false);
      simple == null && (simple = false);
      ref$ = self = this, name = ref$.name, subclasses = ref$.subclasses, sensorTypes = ref$.sensorTypes;
      ss = GET_SENSOR_TYPES(self.superclass);
      res$ = [];
      for (i$ = 0, len$ = subclasses.length; i$ < len$; ++i$) {
        child = subclasses[i$];
        res$.push(name + " <|-- " + child.name);
      }
      xs = res$;
      if (simple) {
        res$ = [];
        for (st in sensorTypes) {
          o = sensorTypes[st];
          if (!in$(st, ss)) {
            res$.push(name + " : " + st);
          }
        }
        ys = res$;
      } else {
        res$ = [];
        for (st in sensorTypes) {
          o = sensorTypes[st];
          if (!in$(st, ss)) {
            res$.push(TO_MERMAID_SENSOR_FIELDS(name, st, o));
          }
        }
        ys = res$;
        res$ = [];
        for (i$ = 0, len$ = ys.length; i$ < len$; ++i$) {
          x = ys[i$];
          for (j$ = 0, len1$ = x.length; j$ < len1$; ++j$) {
            y = x[j$];
            res$.push(y);
          }
        }
        ys = res$;
      }
      zs = xs.concat(ys);
      text = zs.join('\n');
      if (!dumpChild) {
        return text;
      }
      if (subclasses.length === 0) {
        return text;
      }
      res$ = [];
      for (i$ = 0, len$ = subclasses.length; i$ < len$; ++i$) {
        c = subclasses[i$];
        res$.push(c.dumpMermaidClass(true, simple));
      }
      children = res$;
      return text + "\n" + children.join('\n');
    };
    Class.prototype.dumpMarkdown = function(){
      var self, ref$, name, p_type, sensorTypes, ss, sTypes, res$, st, fields, header, xs, ys, zs;
      ref$ = self = this, name = ref$.name, p_type = ref$.p_type, sensorTypes = ref$.sensorTypes;
      ss = GET_SENSOR_TYPES(self.superclass);
      res$ = [];
      for (st in sensorTypes) {
        fields = sensorTypes[st];
        if (!in$(st, ss)) {
          res$.push(st);
        }
      }
      sTypes = res$;
      header = "### " + name + " (`" + p_type + "`)";
      if (sTypes.length === 0) {
        return [header, ""];
      }
      xs = "" + header + "\n\n| p_type | s_type | fields |\n|---|---|---|";
      xs = xs.split('\n');
      res$ = [];
      for (st in sensorTypes) {
        fields = sensorTypes[st];
        if (!in$(st, ss)) {
          res$.push("| `" + p_type + "` | `" + st + "` | " + GET_SENSOR_FIELD_NAMES_FOR_MARKDOWN(fields) + " |");
        }
      }
      ys = res$;
      zs = xs.concat(ys, [""]);
      return zs;
    };
    return Class;
  }());
  ClassManager = (function(){
    ClassManager.displayName = 'ClassManager';
    var prototype = ClassManager.prototype, constructor = ClassManager;
    function ClassManager(schema){
      this.schema = schema;
      this.classes = [];
      this.classMap = {};
      return;
    }
    ClassManager.prototype.init = function(done){
      var self, schema, classes, name, clazz, res$, i$, len$, c, f;
      schema = (self = this).schema;
      self.classes = classes = (function(){
        var ref$, results$ = [];
        for (name in ref$ = schema) {
          clazz = ref$[name];
          results$.push(new Class(clazz, self));
        }
        return results$;
      }());
      res$ = {};
      for (i$ = 0, len$ = classes.length; i$ < len$; ++i$) {
        c = classes[i$];
        res$[c.name] = c;
      }
      self.classMap = res$;
      f = function(c, cb){
        return c.init(cb);
      };
      return async.eachSeries(classes, f, function(initErr){
        if (initErr != null) {
          return done(initErr);
        }
        return done();
      });
    };
    ClassManager.prototype.getClazz = function(name){
      return this.classMap[name];
    };
    ClassManager.prototype.generateMermaidClassDiagram = function(fullpath, simple){
      var self, ref$, classes, classMap, names, res$, i$, len$, c, top, ys, xs, zs, text;
      fullpath == null && (fullpath = "/tmp/schema.mmd");
      simple == null && (simple = false);
      ref$ = self = this, classes = ref$.classes, classMap = ref$.classMap;
      res$ = [];
      for (i$ = 0, len$ = classes.length; i$ < len$; ++i$) {
        c = classes[i$];
        res$.push(c.name);
      }
      names = res$;
      DBG("names => " + names.join(', '));
      res$ = [];
      for (i$ = 0, len$ = classes.length; i$ < len$; ++i$) {
        c = classes[i$];
        if (c.superclass == null) {
          res$.push(c);
        }
      }
      top = res$;
      ys = ["classDiagram"];
      res$ = [];
      for (i$ = 0, len$ = top.length; i$ < len$; ++i$) {
        c = top[i$];
        res$.push(c.dumpMermaidClass(true, simple));
      }
      xs = res$;
      zs = ys.concat(xs);
      text = zs.join('\n');
      return fs.writeFile(fullpath, text, function(err){
        if (err != null) {
          return console.dir(err);
        }
        return console.log("\n\nYou can copy and paste following text to https://mermaidjs.github.io/mermaid-live-editor/\nto generate SVG:\n------\n\n" + text + "\n\n------\nOr, run this command:\n\n    ./node_modules/mermaid.cli/index.bundle.js -i " + fullpath + " -o " + fullpath + ".png\n    ./node_modules/mermaid.cli/index.bundle.js -i " + fullpath + " -o " + fullpath + ".pdf\n    ./node_modules/mermaid.cli/index.bundle.js -i " + fullpath + " -o " + fullpath + ".svg\n    open " + fullpath + ".png\n    open " + fullpath + ".pdf\n    open -a \"Google Chrome\" " + fullpath + ".svg");
      });
    };
    ClassManager.prototype.generateMarkdown = function(fullpath, source){
      var self, ref$, classes, classMap, names, res$, i$, len$, c, xs, x, j$, len1$, a, ys, zs, text;
      fullpath == null && (fullpath = "/tmp/schema.md");
      source == null && (source = "");
      ref$ = self = this, classes = ref$.classes, classMap = ref$.classMap;
      res$ = [];
      for (i$ = 0, len$ = classes.length; i$ < len$; ++i$) {
        c = classes[i$];
        res$.push(c.name);
      }
      names = res$;
      DBG("names => " + names.join(', '));
      res$ = [];
      for (i$ = 0, len$ = classes.length; i$ < len$; ++i$) {
        c = classes[i$];
        res$.push(c.dumpMarkdown());
      }
      xs = res$;
      res$ = [];
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        for (j$ = 0, len1$ = x.length; j$ < len1$; ++j$) {
          a = x[j$];
          res$.push(a);
        }
      }
      xs = res$;
      ys = [];
      zs = ["![](" + path.basename(source) + ".png)", ""].concat(xs, ys);
      text = zs.join('\n');
      return fs.writeFile(fullpath, text, function(err){
        if (err != null) {
          return console.dir(err);
        }
        return console.log("written to " + fullpath);
      });
    };
    ClassManager.prototype.generateJson = function(fullpath, source){
      var self, classes, xs, res$, i$, len$, c, text;
      fullpath == null && (fullpath = "/tmp/schema.md");
      source == null && (source = "");
      classes = (self = this).classes;
      res$ = [];
      for (i$ = 0, len$ = classes.length; i$ < len$; ++i$) {
        c = classes[i$];
        res$.push(c.toOutputJson());
      }
      xs = res$;
      text = JSON.stringify(xs, null, '  ');
      return fs.writeFile(fullpath, text, function(err){
        if (err != null) {
          return console.dir(err);
        }
        return console.log("written to " + fullpath);
      });
    };
    return ClassManager;
  }());
  argv = yargs.alias('s', 'schema').describe('s', 'the input schema file, e.g. schema.ls').alias('f', 'format').describe('f', 'the output file format, e.g. mermaid, merimaid-simple, markdown, json')['default']('f', 'markdown').alias('v', 'verbose').describe('v', 'enable verbose output messages')['default']('v', false).demandOption(['schema', 'format', 'verbose']).boolean(['verbose']).strict().help().argv;
  schema = argv.schema, format = argv.format, verbose = argv.verbose;
  global.verbose = verbose;
  DBG("schema => " + schema);
  DBG("format => " + format);
  DBG("output => " + output);
  DBG("verbose => " + verbose);
  if (format !== 'markdown' && format !== 'mermaid' && format !== 'mermaid-simple' && format !== 'json') {
    return console.error("invalid format: " + format);
  }
  output = (function(){
    switch (format) {
    case 'mermaid':
      return schema + ".mmd";
    case 'mermaid-simple':
      return schema + ".simple.mmd";
    case 'markdown':
      return schema + ".md";
    case 'json':
      return schema + ".json";
    default:
      return schema + ".txt";
    }
  }());
  LOAD_LIVESCRIPT(schema, function(loadErr, SCHEMA){
    var manager;
    if (loadErr != null) {
      return console.error(loadErr);
    }
    manager = global.manager = new ClassManager(SCHEMA);
    return manager.init(function(initErr){
      if (initErr != null) {
        return console.error(initErr);
      }
      if (format === 'mermaid') {
        return manager.generateMermaidClassDiagram(output, false);
      }
      if (format === 'mermaid-simple') {
        return manager.generateMermaidClassDiagram(output, true);
      }
      if (format === 'markdown') {
        return manager.generateMarkdown(output, schema);
      }
      if (format === 'json') {
        return manager.generateJson(output);
      }
    });
  });
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
